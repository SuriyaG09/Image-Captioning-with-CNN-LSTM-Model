# -*- coding: utf-8 -*-
"""ICG_app.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-bWWAsm-DTsbtufGTX6MQmrSxx7n3MSM
"""

!pip install flask-uploads

!pip install pyngrok

!pip install sumy

from pickle import load
from numpy import argmax
from tensorflow.keras.utils import pad_sequences
from keras.applications.vgg16 import VGG16
from tensorflow.keras.utils import load_img, img_to_array
from keras.applications.vgg16 import preprocess_input
from keras.models import Model
from keras.models import load_model
from flask import Flask,request
from flask_uploads import UploadSet, configure_uploads, IMAGES
from flask import render_template
from pyngrok import ngrok
from sumy.parsers.plaintext import PlaintextParser
from sumy.nlp.tokenizers import Tokenizer
from sumy.summarizers.lex_rank import LexRankSummarizer
import nltk
nltk.download('punkt')

#Generate Captions for a Fresh Image

# map an integer to a word
def word_for_id(integer, tokenizer):

    # Maps an integer to a word using the tokenizer's word index
    # Returns the word corresponding to the given integer index
    # If no match is found, returns None

    for word, index in tokenizer.word_index.items():
        if index == integer:
            return word
    return None

def generate_desc(model, tokenizer, photo, max_length):
    # Generates a description for an image using the provided model and tokenizer
    # Inputs:
    #   - model: The trained model used for generating descriptions
    #   - tokenizer: The tokenizer used for encoding the text data
    #   - photo: The image features extracted from the VGG16 model
    #   - max_length: The maximum length of the generated sequence
    # Returns:
    #   - The generated description for the image

    # Initializes the input sequence with the start token
    in_text = 'startseq'

    # Iterates over the specified maximum length
    for i in range(max_length):
        # Integer encodes the input sequence
        sequence = tokenizer.texts_to_sequences([in_text])[0]
        # Pads the input sequence to the maximum length
        sequence = pad_sequences([sequence], maxlen=max_length)
        # Predicts the next word based on the photo and input sequence
        yhat = model.predict([photo, sequence], verbose=0)
        # Converts the predicted probability to an integer
        yhat = argmax(yhat)
        # Maps the integer to a word
        word = word_for_id(yhat, tokenizer)
        # Stops the generation process if no word match is found
        if word is None:
            break
        # Appends the predicted word to the input sequence
        in_text += ' ' + word
        # Stops the generation process if the end token is predicted
        if word == 'endseq':
            break

    # Returns the generated description
    return in_text

def extract_features(filename):
    # Extracts features from the provided image file using the VGG16 model
    # Inputs:
    #   - filename: The path to the image file
    # Returns:
    #   - The extracted features of the image

    # Loads the VGG16 model
    model = VGG16()
    # Removes the last layer of the model
    model.layers.pop()
    # Creates a new model without the last layer
    model = Model(inputs=model.inputs, outputs=model.layers[-2].output)

    # Loads the image and preprocesses it
    image = load_img(filename, target_size=(224, 224))
    image = img_to_array(image)
    image = image.reshape((1, image.shape[0], image.shape[1], image.shape[2]))
    image = preprocess_input(image)

    # Extracts the features of the image using the VGG16 model
    feature = model.predict(image, verbose=0)

    # Returns the extracted features
    return feature

def generate_caption(image_path):
    # Generates a caption for the provided image using the trained model and tokenizer
    # Inputs:
    #   - image_path: The path to the image file
    # Returns:
    #   - The generated caption for the image

    # Loads the tokenizer and trained model
    tokenizer = load(open('/content/drive/MyDrive/Smart_AI/Final/tokenizer.pkl', 'rb'))
    model = load_model('/content/drive/MyDrive/Smart_AI/Final/model.h5')
    max_length = 37  # The maximum length of the generated sequence

    # Extracts features from the image
    photo = extract_features(image_path)

    # Generates the description for the image
    description = generate_desc(model, tokenizer, photo, max_length)

    # Preprocesses the description by removing the start and end tokens
    description = description.split(" ")[1:-1]
    description = " ".join(description)
    description = description.lower()

    # Summarizes the description using LexRank
    parser = PlaintextParser.from_string(description, Tokenizer("english"))
    summarizer = LexRankSummarizer()
    summary = summarizer(parser.document, sentences_count=1)
    caption = " ".join(str(sentence) for sentence in summary[0].words[:10])

    # Returns the generated caption
    return caption

portno = 5000  # Port number for the Flask application

# Setting up ngrok and generating a public URL
ngrok.set_auth_token("2RSNYtZX5tFXQ54CaMyOemK9AzU_5gjcxQe32o5ts1nzSNTK1")
public_url = ngrok.connect(portno).public_url

# Printing the global link for accessing the application
print(f"To access the global link, please click {public_url}")

# Initializing the Flask application
app = Flask(__name__)

# Configuring the uploaded photos destination directory
photos = UploadSet('photos', IMAGES)
path = 'static/img'
app.config['UPLOADED_PHOTOS_DEST'] = 'static/img'
configure_uploads(app, photos)

@app.route("/", methods=["GET", "POST"])
def homepage():
    # Render the homepage template
    return render_template('homepage.html')

@app.route("/upload", methods=["GET", "POST"])
def upload():
    description = None
    p = None
    if request.method == "POST" and 'photo' in request.files:
        # Save the uploaded photo
        filename = photos.save(request.files['photo'])
        p = path+'/'+filename
        # Generate the caption for the uploaded photo
        description = generate_caption(p)
    # Render the upload template with the generated caption and the uploaded photo
    return render_template('upload.html', cp=description, src=p)

@app.route('/developer', methods=["GET", "POST"])
def developer():
    # Render the developer template
    return render_template('dev.html')

if __name__ == "__main__":
    # Run the Flask application on the specified port
    app.run(port=portno)